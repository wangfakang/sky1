{"name":"Sky","tagline":"Tengine Dynamic Dns 的解析","body":"`` 对proxy_pass的分析：\r\n``\r\n\r\n# 内容： \r\n\r\n\r\n\r\n\r\n###  proxy_pass后面使用变量时性能的影响:     \r\n\r\n１．在proxy_pass模块中后面跟变量与常量的区别：       \r\n====\r\n    (1).如果在proxy_pass后面给的是一个具体的upstream，则nginx在proxy_pass模块的时候会设置\r\n    proxy_length为null则后面就不会执行ngx_http_proxy_eval就导致resolved为null，则在upstream\r\n    模块的时候ngx_http_upstream_init_request中就直接执行uscf = u->conf->upstream不会去遍历\r\n    upstream list.否则在proxy_pass中ngx_http_script_variables_count中统计变量的个数是不为０的\r\n    ，则会执行ngx_http_script_compile函数会执行ngx_http_script_init_arrys函数(这个函数会进行相\r\n    关变量长度的分配工作)，最后在ngx_http_proxy_handler中判断其proxy_length进行执行\r\n    ngx_http_proxy_eval函数，     \r\n    (2).在这个函数中会调用ngx_parse_url函数进行相关url的解析工作而且还会为resolved进行分配空间，\r\n    最后在upstream模块中调用ngx_http_upstream_init_request中就会去访问相应的upstream　list从而\r\n    来进行判断（umcf->upstreams.elts）\r\n    (3).当proxy_pass后面给的是变量的时候根据上面知道，没来一个请求的时候就会去遍历upstream list，\r\n    这样会是qps的一个性能瓶颈，在tengine中为了解决这个问题，使用了red_black_tree来解决这个问题\r\n    －－－使用红黑树来存储upstream.\r\n\r\n\r\n\r\n２．proxy_pass后面的url最后有反斜杠的区别：   \r\n====\r\n    (1).当proxy_pass后面给的url有加反斜杠的时候，此时不会把当前location中的path加到proxy_pass\r\n    后面，否则会加上的．\r\n\r\n\r\n３．什么时候proxy_pass后面必须要给一个变量：   \r\n====\r\n    (1)什么时候需要使用变量，那就看看使用变量与否的区别是啥就一目了然了．     \r\n   \r\n\r\n\r\n４．相关防盗链（摘自知道）:        \r\n====\r\n\r\n    (1).nginx为了实现反向代理的需求而增加了一个ngx_http_proxy_module模块。其中proxy_set_header\r\n    指令就是该模块需要读取的配置文件。在这里，所有设置的值的含义和http请求同中的含义完全相同，\r\n    除了Host外还有X-Forward-For。\r\n    (2).Host的含义是表明请求的主机名，因为nginx作为反向代理使用，而如果后端真是的服务器设置有\r\n    类似防盗链或者根据http请求头中的host字段来进行路由或判断功能的话，如果反向代理层的nginx不\r\n    重写请求头中的host字段，将会导致请求失败【默认反向代理服务器会向后端真实服务器发送请求，并\r\n    且请求头中的host字段应为proxy_pass指令设置的服务器。\r\n    (3).同理，X_Forward_For字段表示该条http请求是有谁发起的？如果反向代理服务器不重写该请求头\r\n    的话，那么后端真实服务器在处理时会认为所有的请求都来在反向代理服务器，如果后端有防攻击策\r\n    略的话，那么机器就被封掉了。因此，在配置用作反向代理的nginx中一般会增加两条配置，修改http\r\n    的请求头：\r\n    proxy_set_header Host $http_host;\r\n    proxy_set_header X-Forward-For $remote_addr;\r\n    (4)这里的$http_host和$remote_addr都是nginx的导出变量，可以再配置文件中直接使用。如果Host\r\n    请求头部没有出现在请求头中，则$http_host值为空，但是$host值为主域名。因此，一般而言，会用\r\n    $host代替$http_host变量，从而避免http请求中丢失Host头部的情况下Host不被重写的失误．\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 有问题反馈\r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\n## 感激\r\n\r\n### chunshengsterATgmail.com\r\n\r\n\r\n## 关于作者\r\n\r\n### Linux\\nginx\\golang\\c\\c++爱好者\r\n### 欢迎一起交流  一起学习# \r\n","google":"tengine  dynamic  dns   upstream 动态解析","note":"Don't delete this file! It's used internally to help with page regeneration."}