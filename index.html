<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Sky by wangfakang</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Sky</h1>
        <p class="header">Tengine Dynamic Dns 的解析</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/wangfakang/sky/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/wangfakang/sky/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/wangfakang/sky">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/wangfakang">wangfakang</a></p>


      </header>
      <section>
        <p><code>对NGX_HTTP_UPSTREAM_DYNAMIC_MODULE的分析：
</code></p>

<h1>
<a id="内容" class="anchor" href="#%E5%86%85%E5%AE%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>内容：</h1>

<h2>
<a id="一配置说明" class="anchor" href="#%E4%B8%80%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a>一：配置说明</h2>

<h2>
<a id="二代码解析" class="anchor" href="#%E4%BA%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>二：代码解析</h2>

<h2>
<a id="三总结注意点" class="anchor" href="#%E4%B8%89%E6%80%BB%E7%BB%93%E6%B3%A8%E6%84%8F%E7%82%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>三：总结注意点</h2>

<h3>
<a id="一配置说明-1" class="anchor" href="#%E4%B8%80%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>一：配置说明</h3>

<div class="highlight highlight-nginx"><pre><span class="pl-k">upstream</span> <span class="pl-en">backend </span>{
        <span class="pl-k">dynamic_resolve</span> fallback=stale fail_timeout=30s;   
        <span class="pl-k">server</span> www.baidu.com;        
    }
    <span class="pl-k">server</span> {
        <span class="pl-k">location</span> <span class="pl-en">/ </span>{
            <span class="pl-k">proxy_pass</span> http://backend;
        }
    }</pre></div>

<p>指定在某个upstream中启用动态域名解析功能。</p>

<p>解析:
其中有一个结构体类型:</p>

<div class="highlight highlight-c"><pre><span class="pl-c1">ngx_http_upstream_dynamic_srv_t</span>  {
    <span class="pl-c1">ngx_int_t</span>     enabled;
    <span class="pl-c1">ngx_int_t</span>     fallback;
    <span class="pl-c1">time_t</span>        fail_timeout;
    <span class="pl-c1">time_t</span>        fail_check;

    ngx_http_upstream_init_pt  original_init_get_peer;
        <span class="pl-c1">ngx_http_upstream_init_peer_t</span>  original_init_peer;
}</pre></div>

<hr>

<p>属性含义：
    fallback参数指定了当域名无法解析时采取的动作:</p>

<pre><code>stale, 使用tengine启动的时候获取的旧地址
next, 选择upstream中的下一个server
shutdown, 结束当前请求
fail_timeout参数指定了将DNS服务当做无法使用的时间，也就是当某次DNS请求失败后，假定后续多长的时间内DNS服务依然不可用，以减少对无效DNS的查询。
</code></pre>

<h3>
<a id="二代码解析-1" class="anchor" href="#%E4%BA%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>二：代码解析</h3>

<ul>
<li>发现dynamic_resolve指令的时候调用该函数进行处理</li>
</ul>

<div class="highlight highlight-c"><pre><span class="pl-k">static</span> <span class="pl-k">char</span> *
<span class="pl-en">ngx_http_upstream_dynamic</span>(<span class="pl-c1">ngx_conf_t</span> *cf, <span class="pl-c1">ngx_command_t</span> *cmd, <span class="pl-k">void</span> *conf)
{
    <span class="pl-c1">ngx_http_upstream_srv_conf_t</span>            *uscf;
    <span class="pl-c1">ngx_http_upstream_dynamic_srv_conf_t</span>    *dcf;
    <span class="pl-c1">ngx_str_t</span>   *value, s;
    <span class="pl-c1">ngx_uint_t</span>   i;
    <span class="pl-c1">time_t</span>       fail_timeout;
    <span class="pl-c1">ngx_int_t</span>    fallback;

    uscf = <span class="pl-c1">ngx_http_conf_get_module_srv_conf</span>(cf, ngx_http_upstream_module);

    dcf = <span class="pl-c1">ngx_http_conf_upstream_srv_conf</span>(uscf,
                                          ngx_http_upstream_dynamic_module);

    <span class="pl-k">if</span> (dcf-&gt;original_init_upstream) {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>is duplicate<span class="pl-pds">"</span></span>;
    }
    <span class="pl-c">//设置原有的回调函数（可以叫做记录，本来应该赋给uscf-&gt;peer.init_upstream的）</span>
    dcf-&gt;original_init_upstream = uscf-&gt;peer.<span class="pl-smi">init_upstream</span>
                                  ? uscf-&gt;peer.<span class="pl-smi">init_upstream</span>
                                  : ngx_http_upstream_init_round_robin;

    uscf-&gt;peer.<span class="pl-smi">init_upstream</span> = ngx_http_upstream_init_dynamic;

    <span class="pl-c">/* read options */</span>

    <span class="pl-k">return</span> NGX_CONF_OK;
}</pre></div>

<ul>
<li>上面设置的uscf-&gt;peer.init_upstream函数在ngx_http_upstream_init_main_conf中调用，其uscf-&gt;peer.init_upstream
指向原型如下：</li>
</ul>

<div class="highlight highlight-c"><pre><span class="pl-k">static</span> <span class="pl-c1">ngx_int_t</span>
<span class="pl-en">ngx_http_upstream_init_dynamic</span>(<span class="pl-c1">ngx_conf_t</span> *cf,
    <span class="pl-c1">ngx_http_upstream_srv_conf_t</span> *us)
{

    <span class="pl-c">//此处执行一个后端的负载均衡算法，默认是round_robin</span>
    <span class="pl-k">if</span> (dcf-&gt;<span class="pl-c1">original_init_upstream</span>(cf, us) != NGX_OK) {
        <span class="pl-k">return</span> NGX_ERROR;
    }

    <span class="pl-k">if</span> (us-&gt;servers) {
        server = us-&gt;servers-&gt;elts;

        <span class="pl-k">for</span> (i = <span class="pl-c1">0</span>; i &lt; us-&gt;servers-&gt;nelts; i++) {
            host = server[i].<span class="pl-smi">host</span>;
            <span class="pl-c">//将ip地址转换为长整形数字</span>
            <span class="pl-k">if</span> (<span class="pl-c1">ngx_inet_addr</span>(host.<span class="pl-smi">data</span>, host.<span class="pl-smi">len</span>) == INADDR_NONE) {
                <span class="pl-k">break</span>;
            }
        }

        <span class="pl-k">if</span> (i == us-&gt;servers-&gt;nelts) {
            dcf-&gt;enabled = <span class="pl-c1">0</span>;

            <span class="pl-k">return</span> NGX_OK;
        }
    }
    <span class="pl-c">// us-&gt;peer.init 默认是init_round_robin_peer函数  </span>
    dcf-&gt;original_init_peer = us-&gt;peer.<span class="pl-smi">init</span>;
    <span class="pl-c">//下面是当一个请求来到的时候进行调用该函数</span>
    us-&gt;peer.<span class="pl-smi">init</span> = ngx_http_upstream_init_dynamic_peer;
    <span class="pl-c">//把其设置为激活状态</span>
    dcf-&gt;enabled = <span class="pl-c1">1</span>;

    <span class="pl-k">return</span> NGX_OK;
}</pre></div>

<ul>
<li>其中在ngx_http_upstream_init_request中调用us-&gt;peer.init，其中在上面函数中其指向
ngx_http_upstream_init_dynamic_peer如下：</li>
</ul>

<div class="highlight highlight-c"><pre><span class="pl-k">static</span> <span class="pl-c1">ngx_int_t</span>
<span class="pl-en">ngx_http_upstream_init_dynamic_peer</span>(<span class="pl-c1">ngx_http_request_t</span> *r,
    <span class="pl-c1">ngx_http_upstream_srv_conf_t</span> *us)
{
    <span class="pl-c">//默认是init_round_robin_peer</span>
    <span class="pl-k">if</span> (dcf-&gt;<span class="pl-c1">original_init_peer</span>(r, us) != NGX_OK) {
        <span class="pl-k">return</span> NGX_ERROR;
    }
    <span class="pl-c">//下面就是一点小的技巧，修改原有回调指向，其实就想在原来的函数基础上增加自己的功能，自己的函数中再次调用原来的函数</span>
    <span class="pl-c">//这个思想值得学习</span>
    dp-&gt;conf = dcf;
    dp-&gt;upstream = r-&gt;upstream;
    dp-&gt;data = r-&gt;upstream-&gt;peer.<span class="pl-smi">data</span>;
    dp-&gt;original_get_peer = r-&gt;upstream-&gt;peer.<span class="pl-smi">get</span>;
    dp-&gt;original_free_peer = r-&gt;upstream-&gt;peer.<span class="pl-smi">free</span>;
    dp-&gt;request = r;

    r-&gt;upstream-&gt;peer.<span class="pl-smi">data</span> = dp;
    r-&gt;upstream-&gt;peer.<span class="pl-smi">get</span> = ngx_http_upstream_get_dynamic_peer;
    r-&gt;upstream-&gt;peer.<span class="pl-smi">free</span> = ngx_http_upstream_free_dynamic_peer;

    <span class="pl-k">return</span> NGX_OK;
}

最后在ngx_http_upstream_init_request函数中调用ngx_http_upstream_connect(r, u)在其又调用ngx_event_connect_peer(&amp;u-&gt;peer)
 rc = pc-&gt;<span class="pl-en">get</span>(pc, pc-&gt;data);其中pc-&gt;get就是指向ngx_http_upstream_get_dynamic_peer;此时就完成了在upstream模块选择使用动态</pre></div>

<ul>
<li>dns查询后端peer了。其中ngx_http_upstream_get_dynamic_peer如下：</li>
</ul>

<div class="highlight highlight-c"><pre><span class="pl-k">static</span> <span class="pl-c1">ngx_int_t</span>
 <span class="pl-en">ngx_http_upstream_get_dynamic_peer</span>(<span class="pl-c1">ngx_peer_connection_t</span> *pc, <span class="pl-k">void</span> *data)
{
    .....

    <span class="pl-k">if</span> (pc-&gt;resolved == NGX_HTTP_UPSTREAM_DR_OK) {
        <span class="pl-k">return</span> NGX_OK;
    }

    dscf = bp-&gt;conf;
    r = bp-&gt;request;
    u = r-&gt;upstream;
   <span class="pl-c">//当dns无法解析的时候  按照配置文件所选择的方式进行执行   </span>
    <span class="pl-k">if</span> (pc-&gt;resolved == NGX_HTTP_UPSTREAM_DR_FAILED) {

        <span class="pl-c1">ngx_log_debug1</span>(NGX_LOG_DEBUG_HTTP, pc-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                       <span class="pl-s"><span class="pl-pds">"</span>resolve failed! fallback: <span class="pl-c1">%u</span>i<span class="pl-pds">"</span></span>, dscf-&gt;fallback);

        <span class="pl-k">switch</span> (dscf-&gt;fallback) {
        <span class="pl-c">//当无法访问的时候还是使用旧的解析结果</span>
        <span class="pl-k">case</span> NGX_HTTP_UPSTREAM_DYN_RESOLVE_STALE:
            <span class="pl-k">return</span> NGX_OK;
          <span class="pl-c">//当无法访问的时候把当其关闭</span>
        <span class="pl-k">case</span> NGX_HTTP_UPSTREAM_DYN_RESOLVE_SHUTDOWN:
            <span class="pl-c1">ngx_http_upstream_finalize_request</span>(r, u, NGX_HTTP_BAD_GATEWAY);
            <span class="pl-k">return</span> NGX_YIELD;
          <span class="pl-c">//当无法访问的时候默认使用下一个server</span>
        <span class="pl-k">default</span>:
            <span class="pl-c">/* default fallback action: check next upstream */</span>
            <span class="pl-k">return</span> NGX_DECLINED;
        }

        <span class="pl-k">return</span> NGX_DECLINED;
    }
    <span class="pl-c">//当没有失败的时候则进行超时时间的判断，在timeout时间内dns是无效的</span>
    <span class="pl-k">if</span> (dscf-&gt;fail_check
        &amp;&amp; (<span class="pl-c1">ngx_time</span>() - dscf-&gt;fail_check &lt; dscf-&gt;fail_timeout))
    {
        <span class="pl-c1">ngx_log_debug1</span>(NGX_LOG_DEBUG_HTTP, pc-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                       <span class="pl-s"><span class="pl-pds">"</span>in fail timeout period, fallback: <span class="pl-c1">%u</span>i<span class="pl-pds">"</span></span>, dscf-&gt;fallback);

        <span class="pl-k">switch</span> (dscf-&gt;fallback) {

        <span class="pl-k">case</span> NGX_HTTP_UPSTREAM_DYN_RESOLVE_STALE:
            <span class="pl-k">return</span> bp-&gt;<span class="pl-c1">original_get_peer</span>(pc, bp-&gt;data);

        <span class="pl-k">case</span> NGX_HTTP_UPSTREAM_DYN_RESOLVE_SHUTDOWN:
            <span class="pl-c1">ngx_http_upstream_finalize_request</span>(r, u, NGX_HTTP_BAD_GATEWAY);
            <span class="pl-k">return</span> NGX_YIELD;

        <span class="pl-k">default</span>:
            <span class="pl-c">/* default fallback action: check next upstream, still need</span>
<span class="pl-c">             * to get peer in fail timeout period</span>
<span class="pl-c">             */</span>
            <span class="pl-k">return</span> bp-&gt;<span class="pl-c1">original_get_peer</span>(pc, bp-&gt;data);
        }

        <span class="pl-k">return</span> NGX_DECLINED;
    }

    <span class="pl-c">//bp-&gt;original_get_peer 其指向各种负载均衡算法的(ip_hash、round_robin、consistent_hash)get_peer</span>

    rc = bp-&gt;<span class="pl-c1">original_get_peer</span>(pc, bp-&gt;data);

    <span class="pl-k">if</span> (rc != NGX_OK) {
        <span class="pl-k">return</span> rc;
    }

    <span class="pl-c">/* resolve name */</span>

    <span class="pl-k">if</span> (pc-&gt;host == <span class="pl-c1">NULL</span>) {
        <span class="pl-c1">ngx_log_debug0</span>(NGX_LOG_DEBUG_HTTP, pc-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                       <span class="pl-s"><span class="pl-pds">"</span>load balancer doesn't support dyn resolve!<span class="pl-pds">"</span></span>);
        <span class="pl-k">return</span> NGX_OK;
    }
    <span class="pl-c">//判断该host是不是一个IP  若是一个IP则直接返回</span>
    <span class="pl-k">if</span> (<span class="pl-c1">ngx_inet_addr</span>(pc-&gt;host-&gt;data, pc-&gt;host-&gt;len) != INADDR_NONE) {
        <span class="pl-c1">ngx_log_debug0</span>(NGX_LOG_DEBUG_HTTP, pc-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                       <span class="pl-s"><span class="pl-pds">"</span>host is an IP address, connect directly!<span class="pl-pds">"</span></span>);
        <span class="pl-k">return</span> NGX_OK;
    }

    clcf = <span class="pl-c1">ngx_http_get_module_loc_conf</span>(r, ngx_http_core_module);
    <span class="pl-k">if</span> (clcf-&gt;resolver == <span class="pl-c1">NULL</span>) {
        <span class="pl-c1">ngx_log_error</span>(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                      <span class="pl-s"><span class="pl-pds">"</span>resolver has not been configured!<span class="pl-pds">"</span></span>);
        <span class="pl-k">return</span> NGX_OK;
    }

    temp.<span class="pl-smi">name</span> = *pc-&gt;host;
    <span class="pl-c">//开始准备DNS解析 </span>
    ctx = <span class="pl-c1">ngx_resolve_start</span>(clcf-&gt;resolver, &amp;temp);
    <span class="pl-k">if</span> (ctx == <span class="pl-c1">NULL</span>) {
        <span class="pl-c1">ngx_log_error</span>(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                      <span class="pl-s"><span class="pl-pds">"</span>resolver start failed!<span class="pl-pds">"</span></span>);
        <span class="pl-k">return</span> NGX_OK;
    }
    <span class="pl-c">//当没有配置dns服务器的时候</span>
    <span class="pl-k">if</span> (ctx == NGX_NO_RESOLVER) {
        <span class="pl-c1">ngx_log_error</span>(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                      <span class="pl-s"><span class="pl-pds">"</span>resolver started but no resolver!<span class="pl-pds">"</span></span>);
        <span class="pl-k">return</span> NGX_OK;
    }

    ctx-&gt;name = *pc-&gt;host;
    <span class="pl-c">/* TODO remove */</span>
    <span class="pl-c">// ctx-&gt;type = NGX_RESOLVE_A;</span>
    <span class="pl-c">/* END */</span>
    <span class="pl-c">//设置其回调函数</span>
    <span class="pl-c">//此函数主要是做一些后续处理，如当dns查询成功或是失败修改一些状态  </span>
    <span class="pl-c">//以及函数ngx_resolve_name_done的调用，用来释放一些空间以及调用ngx_resolver_expire</span>
    <span class="pl-c">//上面函数做一些rn结点的过期检查 </span>
    ctx-&gt;handler = ngx_http_upstream_dynamic_handler;
    ctx-&gt;data = r;
    ctx-&gt;timeout = clcf-&gt;resolver_timeout;

    u-&gt;dyn_resolve_ctx = ctx;
    <span class="pl-c">//根据名字进行dns查询</span>
    <span class="pl-k">if</span> (<span class="pl-c1">ngx_resolve_name</span>(ctx) != NGX_OK) {
        <span class="pl-c1">ngx_log_error</span>(NGX_LOG_ERR, pc-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                      <span class="pl-s"><span class="pl-pds">"</span>resolver name failed!<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);

        u-&gt;dyn_resolve_ctx = <span class="pl-c1">NULL</span>;

        <span class="pl-k">return</span> NGX_OK;
    }

    <span class="pl-k">return</span> NGX_YIELD;
}</pre></div>

<h3>
<a id="三总结注意点-1" class="anchor" href="#%E4%B8%89%E6%80%BB%E7%BB%93%E6%B3%A8%E6%84%8F%E7%82%B9-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>三：总结注意点</h3>

<h3>
<a id="注意点" class="anchor" href="#%E6%B3%A8%E6%84%8F%E7%82%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意点:</h3>

<ul>
<li>
<p>1.当一个域名下对应有多个ip的时候:
  但是在调用ngx_http_upstream_get_dynamic_peer的时候调用round_robin_get_peer选择了一个server,但是其判断该peer的hos
t-&gt;name是一个域名,此时nginx会做域名解析最后只会随机的进行选择一个server进行连接.其nginx是这样做的当一个域名对应多个ip
的时候，对其获得的ip进行随机排序，最后是选择第一个。       </p>

<p>当有多个addr的时候，函数是给 rn-&gt;naddrs 进行随机排序: 
 addrs = ngx_resolver_export(r, rn, 1);
 每次只是选择域名下的第一个addr:<br>
 csin = (struct sockaddr_in *) ctx-&gt;addrs[0].sockaddr;</p>
</li>
<li><p>2.配置了dynamic_resolve指令可能不会生效:
  当在使用ngx_http_upstream_dynamic(upstream动态域名解析模块)模块的时候切记点:只有配置了resolver的时候才会去动态DN
S查询(此处的配置resolver有两处:第一处是在nginx的配置文件中locationserverhttp配置块都可以第二处是nginx会在该路径下读取(
/etc/resolve.conf下寻找)当#define NGX_RESOLVER_FILE  "/etc/resolv.conf"
))</p></li>
<li><p>3.当其upstream模块动态dns生效了如何进行dns解析:
  首先判断该host-&gt;name是一个ip还是一个域名,若是一个ip直接returnok,否则会在本地catche进行查询域名对应的ip,对其域名
进行crc哈希得到一个hash值,然后在name_rbtree中进行查找得到resolvernode节点(rn),进行判断rn?=NULL,当其不为空则表明在catch
e中找到了,然后判断其是否过期,没有过期的话就直接进行选择,执行回调函数ctx-&gt;handlr(ctx)设置pc-&gt;sockaddr进行后端的连接处理.
 当其所访问到的catche过期了则把该节点从队列中删除,然后重新发起dns请求,把得到的域名对应的ip copy到 name_rbtree 
rn中(rn-&gt;u.addrs=addr).(注意在前面只是删除了队列中数据  并没有删除name_rbtree中的节点).</p></li>
<li><p>4.当查询一个catch中不存在的域名的时候:
  这个和第3点就多一步工作分配一个rn节点,并且插入name_rbtree中,得到该值后在插入队列.</p></li>
<li><p>5.缓存中的rn节点失效时间是如何管理的:
  其中在resolver指令有一个参数vailed值(r-&gt;vailed = vailed),其中在进行节点失效与否时有这样一句: rn-&gt;vailed &gt;= ngx_time();
  其中rn-&gt;vailed = ngx_time() + (r-&gt;vailed ? r-&gt;vailed : rn-&gt;ttl):
  其中rn-&gt;ttl = 0xff ff ff ff default  rn-&gt;ttl = min(rn-&gt;ttl,ttl)  ttl 是每次dns返回来的ttl.
  所以其rn节点的有效时间用户可以自己配置,若没有配置则使用dns返回来的ttl作为有效时间.</p></li>
<li><p>6.当本地catch的某一个rn节点长期没有访问时如何处理:
  每次在get_dynamic_peer查询结束的时候（调用ngx_resolve_addr_done），都会检查有没有缓存过期，如果有，就会进行释放。
  其原理就是调用:ngx_resolver_expire  其中:
       q = ngx_queue_last(queue);<br>
       rn = ngx_queue_data(q,ngx_resolver_node_t,queue);
       now=ngx_now  if now &gt; rn-&gt;expire  则把该rn节点分别从queue以及name_rbtree中删除.
       其中每次缓存命中的时候都会 update expire: rn-&gt;expire = r-&gt;expire + ngx_now(); r-&gt;expire=30</p></li>
<li><p>7.区分resolver指令中的vailed与dynamic_resolve中的fail_timeout的区别:
  其中resolver指令中的vailed是catche中rn节点的有效期时间,dynamic_resolve中的fail_timeout表示上次dns解析失败与本次是否可以使用dns解析最大时间间隔(即DNS服务无法使用的时间).</p></li>
<li><p>8.当其resolver后配置了多个server的时候(即有多个dns的时候)：
  nginx 会采用Round Robin的方式轮流查询各个dns server。在方法ngx_resolver_send_query中通过在每次调用时改变last_connection来轮流使用不同的dns server进行查询.</p></li>
<li><p>9.在域名后面是否可以指定weight等参数：
  在upstream模块的server模块若后面给得是一个域名，是可以指定其weight的值，其实可以这样理解一个域名对应有ip（可能有多个ip），其weight值就是其ip对应的weight.其相应的参数是否生效只和相应的负载均衡算法有关，如在使用ip_hash算法的时候其中
backup参数对其无效.</p></li>
<li><p>10.dns本地缓存数据结构以及架构是如何设计的:
   函数ngx_resolver_create()对其进行创建:
   对查询结果的缓存，采用RedBlackTree的数据结构，以要查询名字的Hash作为Key,其中有可能不同域名的hash的值相同,此时则
比较域名的字符串大小插入rbtree中,当然最后查询的时候也是按照同样的规则进行查找,节点信息存放在 struct 
ngx_resolver_node_t中。
   因为resolver是全局的，与任何一个connection都无关，所有需要放在一个随时都可以取到的地方，如ngx_mail_core_srv_conf_t结构体上，在使用时从当前session找到ngx_mail_core_srv_conf_t，然后找到resolver。</p></li>
</ul>

<hr>

<pre><code>   为不阻塞当前线程，Nginx采用了异步的方式进行域名查询。整个查询过程主要分为三个步骤，这点在各种异步处理时都是一样
   的：

     (1).准备函数调用需要的信息，并设置回调方法.
     (2).调用函数.
     (3).处理结束后回调方法被调用.
</code></pre>

<h2>
<a id="有问题反馈" class="anchor" href="#%E6%9C%89%E9%97%AE%E9%A2%98%E5%8F%8D%E9%A6%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>有问题反馈</h2>

<p>在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>

<ul>
<li>邮件(1031379296#qq.com, 把#换成@)</li>
<li>QQ: 1031379296</li>
<li>weibo: <a href="http://weibo.com/u/2786211992/home">@王发康</a>
</li>
</ul>

<h2>
<a id="感激" class="anchor" href="#%E6%84%9F%E6%BF%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>感激</h2>

<h3>
<a id="chunshengsteratgmailcom" class="anchor" href="#chunshengsteratgmailcom" aria-hidden="true"><span class="octicon octicon-link"></span></a>chunshengsterATgmail.com</h3>

<h2>
<a id="关于作者" class="anchor" href="#%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于作者</h2>

<h3>
<a id="linuxnginxgolangcc爱好者" class="anchor" href="#linuxnginxgolangcc%E7%88%B1%E5%A5%BD%E8%80%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linux\nginx\golang\c\c++爱好者</h3>

<h3>
<a id="欢迎一起交流--一起学习" class="anchor" href="#%E6%AC%A2%E8%BF%8E%E4%B8%80%E8%B5%B7%E4%BA%A4%E6%B5%81--%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>欢迎一起交流  一起学习#</h3>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("tengine  dynamic  dns  ");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
